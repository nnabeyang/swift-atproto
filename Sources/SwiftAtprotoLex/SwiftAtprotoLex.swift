import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

public func main(outdir: String, path: String) async throws {
  let url = URL(filePath: path)

  let fileURLs = collectJSONFileURLs(at: url)
  let (schemas, prefixes) = try await decodeSchemas(fileURLs, baseURL: url)
  let defMap = Lex.buildExtDefMap(schemas: schemas, prefixes: prefixes)
  let outdirBaseURL = URL(filePath: outdir)
  try buildOutputDirectories(prefixes: prefixes, baseURL: outdirBaseURL)
  try await generateCodeFiles(schemas: schemas, prefixes: prefixes, defMap: defMap, baseURL: outdirBaseURL)
}

func collectJSONFileURLs(at baseURL: URL) -> [URL] {
  var fileURLs = [URL]()
  if let enumerator = FileManager.default.enumerator(at: baseURL, includingPropertiesForKeys: [.isRegularFileKey], options: [.skipsHiddenFiles, .skipsPackageDescendants]) {
    for case let fileUrl as URL in enumerator {
      do {
        let fileAttributes = try fileUrl.resourceValues(forKeys: [.isRegularFileKey])
        if fileAttributes.isRegularFile!, fileUrl.pathExtension == "json" {
          fileURLs.append(fileUrl)
        }
      } catch {
        print(error, fileUrl)
      }
    }
  }
  return fileURLs
}

func decodeSchemas(_ fileURLs: [URL], baseURL: URL) async throws -> (schemas: [Schema], prefixes: Set<String>) {
  let decoder = JSONDecoder()
  var schemas: [Schema] = []
  var prefixes = Set<String>()

  await withTaskGroup(of: (URL, Schema?).self) { group in
    for fileURL in fileURLs {
      group.addTask {
        do {
          let data = try Data(contentsOf: fileURL)
          let prefix = fileURL.prefix(baseURL: baseURL)
          let schema = try decoder.decode(Schema.self, from: data, configuration: prefix)
          return (fileURL, schema)
        } catch {
          return (fileURL, nil)
        }
      }
    }
    for await (fileURL, schema) in group {
      if let schema {
        schemas.append(schema)
        prefixes.insert(fileURL.prefix(baseURL: baseURL))
      }
    }
  }
  return (schemas, prefixes)
}

func buildOutputDirectories(prefixes: Set<String>, baseURL: URL) throws {
  for prefix in prefixes {
    let filePrefix = prefix.split(separator: ".").joined()
    let outdirURL = baseURL.appending(path: filePrefix)

    if FileManager.default.fileExists(atPath: outdirURL.path) {
      try FileManager.default.removeItem(at: outdirURL)
    }
    try FileManager.default.createDirectory(
      at: outdirURL,
      withIntermediateDirectories: true
    )
  }
}

func generateCodeFiles(
  schemas: [Schema],
  prefixes: Set<String>,
  defMap: ExtDefMap,
  baseURL: URL
) async throws {
  try await withThrowingTaskGroup(of: Void.self) { group in
    for prefix in prefixes {
      group.addTask {
        let filePrefix = prefix.split(separator: ".").joined()
        let outdirURL = baseURL.appending(path: filePrefix)

        let enumName = Lex.structNameFor(prefix: prefix)
        let baseFileURL = outdirURL.appending(path: "\(enumName).swift")
        let baseSrc = Lex.baseFile(prefix: prefix)
        try baseSrc.write(to: baseFileURL, atomically: true, encoding: .utf8)

        try await withThrowingTaskGroup(of: Void.self) { innerGroup in
          for schema in schemas where schema.id.hasPrefix(prefix) {
            innerGroup.addTask {
              if let src = Lex.genCode(for: schema, defMap: defMap) {
                let schemaURL = outdirURL.appending(path: "\(filePrefix)_\(schema.name).swift")
                try src.write(to: schemaURL, atomically: true, encoding: .utf8)
              }
            }
          }
          try await innerGroup.waitForAll()
        }
      }
    }
    try await group.waitForAll()
  }
}

extension URL {
  fileprivate func prefix(baseURL: URL) -> String {
    precondition(path.hasPrefix(baseURL.path))
    let relativeCount = pathComponents.count - baseURL.pathComponents.count
    let url = relativeCount >= 4 ? deletingLastPathComponent() : self
    return url.deletingLastPathComponent().path.dropFirst(baseURL.path.count + 1).replacingOccurrences(of: "/", with: ".")
  }
}

enum Lex {
  private static var fileHeader: Trivia {
    Trivia(pieces: [
      .lineComment("//"),
      .newlines(1),
      .lineComment("// DO NOT EDIT"),
      .newlines(1),
      .lineComment("//"),
      .newlines(1),
      .lineComment("// Generated by swift-atproto"),
      .newlines(1),
      .lineComment("//"),
      .newlines(2),
    ])
  }

  static func baseFile(prefix: String) -> String {
    let src = SourceFileSyntax(
      leadingTrivia: Self.fileHeader,
      statementsBuilder: {
        ImportDeclSyntax(
          path: ImportPathComponentListSyntax([ImportPathComponentSyntax(name: "SwiftAtproto")]),
          trailingTrivia: .newlines(2)
        )
        EnumDeclSyntax(
          modifiers: [
            DeclModifierSyntax(name: .keyword(.public))
          ],
          name: .identifier(Lex.structNameFor(prefix: prefix)),
          memberBlock: MemberBlockSyntax(
            leftBrace: .leftBraceToken(),
            members: MemberBlockItemListSyntax([]),
            rightBrace: .rightBraceToken()
          )
        )
      },
      trailingTrivia: .newline)
    return src.formatted().description
  }

  static func genCode(for schema: Schema, defMap: ExtDefMap) -> String? {
    let prefix = schema.prefix
    let structName = Lex.structNameFor(prefix: prefix)
    let allTypes = schema.allTypes(prefix: prefix).sorted(by: {
      $0.key.localizedStandardCompare($1.key) == .orderedAscending
    })
    let recordTypes = allTypes.filter(\.value.isRecord)
    let otherTypes = allTypes.filter { !$0.value.isRecord }
    let methods: [DeclSyntaxProtocol]? =
      if let main = schema.defs["main"],
        main.isMethod
      {
        Self.writeMethods(
          leadingTrivia: otherTypes.isEmpty ? nil : .newlines(2),
          typeName: Self.nameFromId(id: schema.id, prefix: prefix),
          typeSchema: main,
          defMap: defMap,
          prefix: structNameFor(prefix: prefix)
        )
      } else {
        nil
      }
    let enumExtensionIsNeeded = !otherTypes.isEmpty || methods != nil
    if otherTypes.isEmpty && methods == nil && recordTypes.isEmpty {
      return nil
    }
    let src = SourceFileSyntax(
      leadingTrivia: Self.fileHeader,
      statementsBuilder: {
        ImportDeclSyntax(
          path: ImportPathComponentListSyntax([ImportPathComponentSyntax(name: "SwiftAtproto")])
        )
        ImportDeclSyntax(
          path: ImportPathComponentListSyntax([ImportPathComponentSyntax(name: "Foundation")]),
          trailingTrivia: .newlines(2)
        )
        if enumExtensionIsNeeded {
          ExtensionDeclSyntax(extendedType: TypeSyntax(stringLiteral: structName)) {
            for (i, (name, ot)) in otherTypes.enumerated() {
              ot.lex(leadingTrivia: i == 0 ? nil : .newlines(2), name: name, type: (ot.defName.isEmpty || ot.defName == "main") ? ot.id : "\(ot.id)#\(ot.defName)", defMap: defMap)
            }

            if let methods, methods.count == 2 {
              methods[0]
            }
          }
        }
        if let methods, let method = methods.last {
          ExtensionDeclSyntax(extendedType: TypeSyntax(stringLiteral: "XRPCClientProtocol")) {
            method
          }
        }
        for (i, (name, ot)) in recordTypes.enumerated() {
          ot.lex(leadingTrivia: (!enumExtensionIsNeeded && i == 0) ? nil : .newlines(2), name: name, type: (ot.defName.isEmpty || ot.defName == "main") ? ot.id : "\(ot.id)#\(ot.defName)", defMap: defMap)
        }
      },
      trailingTrivia: .newline)
    return src.formatted().description
  }

  static func writeMethods(leadingTrivia: Trivia? = nil, typeName: String, typeSchema ts: TypeSchema, defMap: ExtDefMap, prefix: String) -> [DeclSyntaxProtocol]? {
    switch ts.type {
    case .procedure(let def as any HTTPAPITypeDefinition), .query(let def as any HTTPAPITypeDefinition):
      return [
        ts.writeErrorDecl(leadingTrivia: leadingTrivia, def: def, typeName: typeName, defMap: defMap),
        ts.writeRPC(leadingTrivia: nil, def: def, typeName: typeName, defMap: defMap, prefix: prefix),
      ].compactMap(\.self)
    default:
      return nil
    }
  }

  static func buildExtDefMap(schemas: [Schema], prefixes: Set<String>) -> ExtDefMap {
    var out = ExtDefMap()
    for schema in schemas {
      for (defName, def) in schema.defs {
        let key = {
          if defName == "main" {
            return schema.id
          }
          return "\(schema.id)#\(defName)"
        }()
        out[key] = ExtDef(type: def)
      }
    }
    return out
  }

  static func nameFromId(id: String, prefix: String) -> String {
    id.trim(prefix: prefix).split(separator: ".").map {
      $0.titleCased()
    }.joined()
  }

  static func structNameFor(prefix: String) -> String {
    "\(prefix.split(separator: ".").joined())types"
  }

  static func caseNameFromId(id: String, prefix: String) -> String {
    id.trim(prefix: "\(prefix).").components(separatedBy: CharacterSet(charactersIn: ".#")).enumerated().map {
      $0 == 0 ? $1 : $1.titleCased()
    }.joined()
  }
}

extension String {
  func trim(prefix: String) -> String {
    guard hasPrefix(prefix) else { return self }
    return String(dropFirst(prefix.count))
  }

  func titleCased() -> String {
    var prev = Character(" ")
    return String(
      map {
        if prev.isWhitespace {
          prev = $0
          return Character($0.uppercased())
        }
        prev = $0
        return $0
      })
  }

  func camelCased() -> String {
    guard !isEmpty else { return "" }
    let words = components(separatedBy: CharacterSet.alphanumerics.inverted).filter { !$0.isEmpty }
    let first = words.first!.lowercased()
    let rest = words.dropFirst().map(\.capitalized)
    return ([first] + rest).joined()
  }
}

extension Substring {
  func titleCased() -> String {
    var prev = Character(" ")
    return String(
      map {
        if prev.isWhitespace {
          prev = $0
          return Character($0.uppercased())
        }
        prev = $0
        return $0
      })
  }
}
